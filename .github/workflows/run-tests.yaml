name: Java CI

on:
  push:
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Setup Gradle Cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: ${{ runner.os }}-gradle-

      - name: Setup Node Cache
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: ${{ runner.os }}-node-

      - name: Build with Gradle
        run: ./gradlew build

      - name: Run tests with Gradle
        run: ./gradlew test

      - name: Generate JaCoCo coverage report
        run: ./gradlew jacocoTestReport

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Dependencies
        run: npm install xml2js

#      - name: Publish JUnit test results
#        uses: dorny/test-reporter@v1
#        with:
#          name: JUnit Tests
#          path: build/test-results/**/*.xml
#          reporter: java-junit

      - name: Generate Combined Test and Coverage Summary
        uses: actions/github-script@v6
        env:
          MINIMUM_COVERAGE: "50"
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const xml2js = require('xml2js');

            const junitPath = path.join('build', 'test-results', 'test', 'TEST-PetriNetTest.xml');
            const jacocoPath = path.join('build', 'reports', 'jacoco', 'test', 'jacocoTestReport.xml');

            let totalTests = 0, failures = 0, errors = 0, skipped = 0, successful = 0;
            let totalLines = 0, coveredLines = 0, missedLines = 0;
            let lineCoveragePercentage = "N/A";

            if (fs.existsSync(junitPath)) {
              const junitXml = fs.readFileSync(junitPath, 'utf-8');
              const parser = new xml2js.Parser();

              parser.parseString(junitXml, (err, result) => {
                if (err) {
                  throw new Error(`Failed to parse JUnit report: ${err.message}`);
                }

                const testsuite = result.testsuite.$;
                totalTests = parseInt(testsuite.tests);
                failures = parseInt(testsuite.failures);
                errors = parseInt(testsuite.errors);
                skipped = parseInt(testsuite.skipped);
                successful = totalTests - failures - errors - skipped;
              });
            }

            if (fs.existsSync(jacocoPath)) {
              const jacocoXml = fs.readFileSync(jacocoPath, 'utf-8');
              const parser = new xml2js.Parser();

              parser.parseString(jacocoXml, (err, result) => {
                if (err) {
                  throw new Error(`Failed to parse JaCoCo report: ${err.message}`);
                }

                const counters = result.report.counter.filter(c => c.$.type === 'LINE');
                counters.forEach(counter => {
                  missedLines += parseInt(counter.$.missed);
                  coveredLines += parseInt(counter.$.covered);
                });

                totalLines = missedLines + coveredLines;
                lineCoveragePercentage = totalLines > 0
                  ? ((coveredLines / totalLines) * 100).toFixed(2) + '%'
                  : '0.00%';
              });
            }

            //  Check for valid coverage percentage
            let auxLineCoveragePercentage = parseFloat(lineCoveragePercentage.replace('%', ''));
            if (auxLineCoveragePercentage < 0 || auxLineCoveragePercentage > 100) {
              core.setFailed(`Invalid line coverage percentage: ${lineCoveragePercentage}`);
            }

            if (auxLineCoveragePercentage < parseFloat(process.env.MINIMUM_COVERAGE)) {
              core.setFailed(`Line coverage is below the minimum threshold of ${process.env.MINIMUM_COVERAGE}%: ${lineCoveragePercentage}`);
            }

            const summary = `
            # Test and Coverage Summary
            
            ## Test Results
            - **Total Tests:** ${totalTests}
            - **Successful:** ${successful}
            - **Failures:** ${failures}
            - **Errors:** ${errors}
            - **Skipped:** ${skipped}
            
            ## Code Coverage
            - **Line Coverage:** ${lineCoveragePercentage}
            - **Total Lines:** ${totalLines}
            - **Covered Lines:** ${coveredLines}
            - **Missed Lines:** ${missedLines}
            `;
            
            console.log(summary);
            await core.summary.addRaw(summary).write();

#name: Java CI
#
#on:
#  push:
#  #pull_request:
#  workflow_dispatch:
#
#jobs:
#  test:
#    runs-on: ubuntu-latest
#    permissions: write-all
#
#    steps:
#      - name: Checkout
#        uses: actions/checkout@v4
#
#      - name: Set up JDK 21
#        uses: actions/setup-java@v3
#        with:
#          java-version: '21'
#          distribution: 'temurin'
#
#      - name: Build with Gradle
#        run: ./gradlew build
#
#      - name: Run tests with Gradle
#        run: ./gradlew test
#
#      - name: Generate JaCoCo coverage report
#        run: ./gradlew jacocoTestReport
#
#      - name: Generate JaCoCo Badge
#        uses: cicirello/jacoco-badge-generator@v2
#        with:
#          jacoco-csv-file: build/reports/jacoco/test/jacocoTestReport.csv
#          generate-summary: true
#          fail-on-coverage-decrease: true
#          fail-if-branches-less-than: "%70"
#          fail-if-coverage-less-than: "40%"
#
#      - name: Publish JUnit test results
#        uses: dorny/test-reporter@v1
#        with:
#          name: JUnit Tests
#          path: build/test-results/**/*.xml
#          reporter: java-junit























#name: Java CI
#
#on:
#  push:
#    #    branches:
#    #      - main
#    #      - dev
#
#  pull_request:
#  workflow_dispatch: # allows us to manually run the actions
#
#jobs:
#  test:
#    runs-on: ubuntu-latest
#    permissions: write-all
#
#    steps:
#      - name: Checkout
#        uses: actions/checkout@v4
#
#      - name: Set up JDK 21
#        uses: actions/setup-java@v3
#        with:
#          java-version: '21'
#          distribution: 'temurin'
#
#      - name: Create directories
#        run: |
#          mkdir -p lib
#          mkdir -p bin
#          mkdir -p test-results
#          mkdir -p coverage-reports
#
#      - name: Download dependencies
#        run: |
#          wget -P lib/ https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/1.9.2/junit-platform-console-standalone-1.9.2.jar
#          wget -P lib/ https://repo1.maven.org/maven2/org/jacoco/org.jacoco.cli/0.8.11/org.jacoco.cli-0.8.11-nodeps.jar
#          wget -P lib/ https://repo1.maven.org/maven2/org/jacoco/org.jacoco.agent/0.8.11/org.jacoco.agent-0.8.11-runtime.jar
#
#      - name: Compile source files
#        run: |
#          javac -d bin \
#                --release 21 \
#                --enable-preview \
#                -cp "lib/*:src" \
#                $(find src -name "*.java")
#
#      - name: Compile test files
#        run: |
#          javac -d bin \
#                --release 21 \
#                --enable-preview \
#                -cp "bin:lib/*" \
#                $(find tests -name "*.java")
#
#      - name: Run tests with coverage
#        run: |
#          java --enable-preview \
#               -javaagent:lib/org.jacoco.agent-0.8.11-runtime.jar=destfile=coverage-reports/jacoco.exec \
#               -jar lib/junit-platform-console-standalone-1.9.2.jar \
#               --class-path bin \
#               --scan-class-path \
#               --include-classname=.*Test \
#               --reports-dir test-results
#
#      - name: Generate coverage report
#        run: |
#          java -jar lib/org.jacoco.cli-0.8.11-nodeps.jar report coverage-reports/jacoco.exec \
#               --classfiles bin \
#               --sourcefiles src \
#               --html coverage-reports/html \
#               --xml coverage-reports/coverage.xml
#
#      - name: Install xml2js
#        run: npm install xml2js
#
#      - name: Parse JaCoCo Report
#        uses: actions/github-script@v6
#        with:
#          script: |
#            const fs = require('fs');
#            const xml2js = require('xml2js');
#            const util = require('util');
#
#            async function parseJacocoCoverage() {
#              try {
#                const jacocoFilePath = 'coverage-reports/coverage.xml';
#
#                // Verificar si existe el archivo
#                if (!fs.existsSync(jacocoFilePath)) {
#                  throw new Error('JaCoCo report not found at: ' + jacocoFilePath);
#                }
#
#                // Leer el archivo XML
#                const xmlData = fs.readFileSync(jacocoFilePath, 'utf-8');
#
#                // Parsear XML a JSON
#                const parser = new xml2js.Parser();
#                const parseXml = util.promisify(parser.parseString);
#                const result = await parseXml(xmlData);
#
#                // Extraer los contadores del reporte
#                const report = result.report;
#                let totalMissed = 0;
#                let totalCovered = 0;
#
#                // Función recursiva para sumar contadores de líneas
#                function sumLineCounters(element) {
#                  if (element.counter) {
#                    const lineCounters = element.counter.filter(c => c.$.type === 'LINE');
#                    for (const counter of lineCounters) {
#                      totalMissed += parseInt(counter.$.missed || 0);
#                      totalCovered += parseInt(counter.$.covered || 0);
#                    }
#                  }
#
#                  // Recursivamente procesar todos los elementos hijos
#                  for (const key in element) {
#                    if (Array.isArray(element[key])) {
#                      element[key].forEach(child => {
#                        if (typeof child === 'object') {
#                          sumLineCounters(child);
#                        }
#                      });
#                    }
#                  }
#                }
#
#                // Comenzar el procesamiento desde la raíz
#                sumLineCounters(report);
#
#                // Calcular métricas
#                const totalLines = totalMissed + totalCovered;
#                const coveragePercentage = totalLines > 0
#                  ? ((totalCovered / totalLines) * 100).toFixed(2)
#                  : '0.00';
#
#                // Generar resumen con mejor formato markdown
#                const summary = `# JaCoCo Code Coverage Report
#
#            ## Summary
#            * **Line Coverage:** ${coveragePercentage}%
#            * **Total Lines:** ${totalLines.toLocaleString()}
#            * **Covered Lines:** ${totalCovered.toLocaleString()}
#            * **Missed Lines:** ${totalMissed.toLocaleString()}
#
#            ---
#
#            > Generated on ${new Date().toISOString().split('T')[0]}
#            `;
#
#                // Logging para debug
#                console.log('Coverage Analysis Results:');
#                console.log(`Total Lines: ${totalLines}`);
#                console.log(`Covered Lines: ${totalCovered}`);
#                console.log(`Missed Lines: ${totalMissed}`);
#                console.log(`Coverage Percentage: ${coveragePercentage}%`);
#
#                // Escribir el resumen en GitHub Actions
#                await core.summary.addRaw(summary).write();
#
#                // Opcional: Establecer output para usar en otros steps
#                core.setOutput('coverage-percentage', coveragePercentage);
#                core.setOutput('total-lines', totalLines);
#                core.setOutput('covered-lines', totalCovered);
#                core.setOutput('missed-lines', totalMissed);
#
#                // Opcional: Fallar el workflow si la cobertura es muy baja
#                const minimumCoverage = 50; // Ajusta según tus necesidades
#                if (parseFloat(coveragePercentage) < minimumCoverage) {
#                  core.setFailed(`Coverage ${coveragePercentage}% is below minimum ${minimumCoverage}%`);
#                }
#
#              } catch (error) {
#                console.error('Error processing JaCoCo report:', error);
#                core.setFailed(error.message);
#              }
#            }
#
#            // Ejecutar el análisis
#            await parseJacocoCoverage();